use clap::Parser;
use eyre::Result;
use std::fs;
use std::path::Path;
use std::process::Command;

const MAIN_RS_PREPEND: &str = r#"#[allow(unused_imports)]
use {
    openvm_k256::Secp256k1Point,
    openvm_p256::P256Point,
    openvm_pairing::{
        bls12_381::{Bls12_381Fp2, Bls12_381G1Affine},
        bn254::{Bn254Fp2, Bn254G1Affine},
    },
};

openvm::init!();

"#;

fn generate_additional_deps(tag: Option<&str>) -> String {
    let tag_part = tag.map_or(String::new(), |tag| format!(r#", tag = "{}""#, tag));

    format!(
        r#"
openvm-algebra-guest = {{ git = "https://github.com/openvm-org/openvm.git"{}, default-features = false }}
openvm-ecc-guest = {{ git = "https://github.com/openvm-org/openvm.git"{}, default-features = false }}
openvm-pairing = {{ git = "https://github.com/openvm-org/openvm.git"{}, features = [
    "bn254",
    "bls12_381",
] }}
openvm-k256 = {{ git = "https://github.com/openvm-org/openvm.git"{}, package = "k256" }}
openvm-p256 = {{ git = "https://github.com/openvm-org/openvm.git"{}, package = "p256" }}
"#,
        tag_part, tag_part, tag_part, tag_part, tag_part
    )
}

const OPENVM_TOML_TEMPLATE: &str = r#"openvm_version = "v1.2"

[app_vm_config.system.config]
max_constraint_degree = 3
continuation_enabled = true
num_public_values = 32
profiling = false

[app_vm_config.system.config.memory_config]
as_height = 3
as_offset = 1
pointer_max_bits = 29
clk_max_bits = 29
decomp = 17
max_access_adapter_n = 32
access_capacity = 16777216

[app_vm_config.rv32i]

[app_vm_config.rv32m]
range_tuple_checker_sizes = [256, 8192]

[app_vm_config.io]

[app_vm_config.keccak]

[app_vm_config.sha256]

[app_vm_config.bigint]
range_tuple_checker_sizes = [256, 8192]

[app_vm_config.modular]
supported_moduli = [
    # bn254 (alt bn128)
    "21888242871839275222246405745257275088696311157297823662689037894645226208583", # coordinate field
    "21888242871839275222246405745257275088548364400416034343698204186575808495617", # scalar field
    # secp256k1
    "115792089237316195423570985008687907853269984665640564039457584007908834671663", # coordinate field
    "115792089237316195423570985008687907852837564279074904382605163141518161494337", # scalar field
    # secp256r1 (p256)
    "115792089210356248762697446949407573530086143415290314195533631308867097853951", # coordinate field
    "115792089210356248762697446949407573529996955224135760342422259061068512044369", # scalar field
    # bls12_381
    "4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787", # coordinate field
    "52435875175126190479447740508185965837690552500527637822603658699938581184513",                                       # scalar field
]

[app_vm_config.fp2]
supported_moduli = [
    ["Bn254Fp2", "21888242871839275222246405745257275088696311157297823662689037894645226208583"],
    ["Bls12_381Fp2", "4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787"],
]

[app_vm_config.pairing]
supported_curves = ["Bn254", "Bls12_381"]

# bn254 (alt bn128)
[[app_vm_config.ecc.supported_curves]]
struct_name = "Bn254G1Affine"
modulus = "21888242871839275222246405745257275088696311157297823662689037894645226208583"
scalar = "21888242871839275222246405745257275088548364400416034343698204186575808495617"
a = "0"
b = "3"

[[app_vm_config.ecc.supported_curves]]
struct_name = "Secp256k1Point"
modulus = "115792089237316195423570985008687907853269984665640564039457584007908834671663"
scalar = "115792089237316195423570985008687907852837564279074904382605163141518161494337"
a = "0"
b = "7"

# secp256r1 (p256)
[[app_vm_config.ecc.supported_curves]]
struct_name = "P256Point"
modulus = "115792089210356248762697446949407573530086143415290314195533631308867097853951"
scalar = "115792089210356248762697446949407573529996955224135760342422259061068512044369"
a = "115792089210356248762697446949407573530086143415290314195533631308867097853948"
b = "41058363725152142129326129780047268409114441015993725554835256314039467401291"

# bls12_381
[[app_vm_config.ecc.supported_curves]]
struct_name = "Bls12_381G1Affine"
modulus = "4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787"
scalar = "52435875175126190479447740508185965837690552500527637822603658699938581184513"
a = "0"
b = "4"
"#;

const OPENVM_INIT_TEMPLATE: &str = r#"// This file is automatically generated by cargo openvm. Do not rename or edit.
openvm_algebra_guest::moduli_macros::moduli_init! { "21888242871839275222246405745257275088696311157297823662689037894645226208583", "21888242871839275222246405745257275088548364400416034343698204186575808495617", "115792089237316195423570985008687907853269984665640564039457584007908834671663", "115792089237316195423570985008687907852837564279074904382605163141518161494337", "115792089210356248762697446949407573530086143415290314195533631308867097853951", "115792089210356248762697446949407573529996955224135760342422259061068512044369", "4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787", "52435875175126190479447740508185965837690552500527637822603658699938581184513" }
openvm_algebra_guest::complex_macros::complex_init! { Bn254Fp2 { mod_idx = 0 }, Bls12_381Fp2 { mod_idx = 6 } }
openvm_ecc_guest::sw_macros::sw_init! { Bn254G1Affine, Secp256k1Point, P256Point, Bls12_381G1Affine }
"#;

#[derive(Debug, Parser)]
#[command(name = "init", about = "Initialize a new OpenVM project")]
pub struct InitCmd {
    #[clap(flatten)]
    init_args: InitArgs,
}

impl InitCmd {
    pub fn run(self) -> Result<()> {
        execute(self.init_args)
    }
}

#[derive(Debug, Parser)]
pub struct InitArgs {
    /// Path to create the package in
    #[clap(value_name = "PATH")]
    path: Option<String>,

    /// Set the package name, default is the directory name
    #[clap(long, value_name = "NAME")]
    name: Option<String>,
}

pub fn execute(args: InitArgs) -> Result<()> {
    println!("Initializing OpenVM project...");

    // Check if cargo openvm is installed
    let check_status = Command::new("cargo")
        .arg("openvm")
        .arg("--help")
        .output()
        .map_err(|_| eyre::eyre!("cargo openvm is not installed. Please install it first."))?;

    if !check_status.status.success() {
        return Err(eyre::eyre!(
            "cargo openvm is not installed or not working properly."
        ));
    }

    // Build the cargo openvm init command
    let mut cmd = Command::new("cargo");
    cmd.arg("openvm").arg("init");

    // Add path if provided
    if let Some(path) = &args.path {
        cmd.arg(path);
    }

    // Add name if provided
    if let Some(name) = &args.name {
        cmd.arg("--name").arg(name);
    }

    // Execute cargo openvm init
    let status = cmd.status()?;
    if !status.success() {
        return Err(eyre::eyre!("Failed to initialize OpenVM project"));
    }

    // Determine the project directory
    let project_dir = if let Some(path) = &args.path {
        Path::new(path).to_path_buf()
    } else {
        std::env::current_dir()?
    };

    // Modify src/main.rs to prepend the required imports
    let main_rs_path = project_dir.join("src").join("main.rs");
    if main_rs_path.exists() {
        let existing_content = fs::read_to_string(&main_rs_path)?;
        let new_content = format!("{}{}", MAIN_RS_PREPEND, existing_content);
        fs::write(&main_rs_path, new_content)?;
    }

    // Modify Cargo.toml to add additional dependencies
    let cargo_toml_path = project_dir.join("Cargo.toml");
    if cargo_toml_path.exists() {
        let cargo_content = fs::read_to_string(&cargo_toml_path)?;

        // Find the openvm dependency line and extract tag, then insert additional dependencies after it
        let lines: Vec<&str> = cargo_content.lines().collect();
        let mut new_lines = Vec::new();
        let mut openvm_found = false;
        let mut extracted_tag = None;

        for line in lines {
            new_lines.push(line);

            // Look for the openvm dependency line
            if !openvm_found && line.contains("openvm = {") {
                // Extract tag from the openvm dependency line
                if let Some(tag_start) = line.find(r#"tag = ""#) {
                    let tag_part = &line[tag_start + 7..]; // Skip 'tag = "'
                    if let Some(tag_end) = tag_part.find('"') {
                        extracted_tag = Some(&tag_part[..tag_end]);
                    }
                }
                openvm_found = true;
            }
        }

        // Generate and add the additional dependencies after processing all lines
        let additional_deps = if openvm_found {
            generate_additional_deps(extracted_tag)
        } else {
            generate_additional_deps(None)
        };

        // Find where to insert the additional dependencies
        if openvm_found {
            // Find the openvm line again and insert after it
            let mut final_lines = Vec::new();
            for line in &new_lines {
                final_lines.push(*line);
                if line.contains("openvm = {") {
                    for dep_line in additional_deps.trim_end().lines() {
                        final_lines.push(dep_line);
                    }
                }
            }
            new_lines = final_lines;
        } else {
            // Append at the end
            for dep_line in additional_deps.trim_end().lines() {
                new_lines.push(dep_line);
            }
        }

        let new_cargo_content = new_lines.join("\n");
        fs::write(&cargo_toml_path, new_cargo_content)?;
    }

    // Create .env.example if it doesn't exist
    let env_example_path = project_dir.join(".env.example");
    if !env_example_path.exists() {
        fs::write(&env_example_path, "AXIOM_API_KEY=\n")?;
    }

    // Create .env if it doesn't exist
    let env_path = project_dir.join(".env");
    if !env_path.exists() {
        fs::write(&env_path, "AXIOM_API_KEY=\n")?;
    }

    // Update .gitignore to include .env and ./openvm
    let gitignore_path = project_dir.join(".gitignore");
    if gitignore_path.exists() {
        let gitignore_content = fs::read_to_string(&gitignore_path)?;
        let additions = vec![".env", "./openvm"];
        let mut updated_content = gitignore_content;

        for addition in &additions {
            if !updated_content.contains(addition) {
                updated_content.push_str(&format!("{}\n", addition));
            }
        }

        fs::write(&gitignore_path, updated_content)?;
    }

    // Create or replace openvm.toml file
    let openvm_toml_path = project_dir.join("openvm.toml");
    fs::write(&openvm_toml_path, OPENVM_TOML_TEMPLATE)?;

    // Create openvm_init.rs file
    let openvm_init_path = project_dir.join("openvm_init.rs");
    fs::write(&openvm_init_path, OPENVM_INIT_TEMPLATE)?;

    Ok(())
}
